## **2. БАЗОВЫЕ АЛГОРИТМЫ И ТЕХНИКИ**

### **I. СОРТИРОВКИ**
*   **Квадратичные**
    *   Bubble Sort
    *   Selection Sort
    *   Insertion Sort
        Binary Insertion Sort, Recursive Insertion Sort
*   **Эффективные O(n log n)**
    *   Merge Sort
        Iterative Merge Sort, Merge Insertion Sort, Recursive Mergesort Array
    *   **Сортировка кучей (Heap Sort)**
    *   Быстрая сортировка (Quick Sort)
        Quick Sort 3 Partition, Recursive Quick Sort
*   **Линейные и почти линейные**
    *   **Counting Sort**
    *   **Цифровая сортировка (Radix Sort)**
        Msd Radix Sort
    *   **Сортировка событий**
*   **Дополнительно:**
    Bead Sort, Bitonic Sort, Bogo Sort, Bucket Sort, Circle Sort, Cocktail Shaker Sort, Comb Sort, Cycle Sort, Cyclic Sort, Double Sort, Dutch National Flag Sort, Exchange Sort, External Sort, Gnome Sort, Intro Sort, Natural Sort, Odd Even Sort, Odd Even Transposition Parallel, Odd Even Transposition Single Threaded, Pancake Sort, Patience Sort, Pigeon Sort, Pigeonhole Sort, Shell Sort, Shrink Shell Sort, Slowsort, Stalin Sort, Stooge Sort, Strand Sort, Tim Sort, Topological Sort, Tree Sort, Unknown Sort, Wiggle Sort

### **II. ПОИСК (SEARCH ALGORITHMS)**

#### **I. ЛИНЕЙНЫЙ И ПОСЛЕДОВАТЕЛЬНЫЙ ПОИСК**

##### **A. БАЗОВЫЙ ЛИНЕЙНЫЙ ПОИСК**
*   **Linear Search (Sequential Search):**
    *   Проход по всем элементам O(n)
    *   Для неотсортированных массивов
    *   Простая реализация
*   **Оптимизации линейного поиска:**
    *   **Sentinel Linear Search:**
        *   Sentinel Linear Search
        *   Добавление искомого элемента в конец
        *   Уменьшение числа проверок условия
    *   **Double Linear Search:**
        *   Double Linear Search
        *   Поиск с двух концов одновременно
        *   Double Linear Search Recursion
*   **Применения:**
    *   Поиск в небольших массивах
    *   Когда данные не отсортированы
    *   Когда нужен первый/последний вхождение

##### **B. ОСОБЫЕ СЛУЧАИ ЛИНЕЙНОГО ПОИСКА**
*   **Search in unsorted array:**
    *   Только линейный поиск
    *   Ожидаемое время O(n)
*   **Search with early exit:**
    *   При нахождении первого подходящего элемента
*   **Search for multiple occurrences:**
    *   Найти все вхождения
    *   Подсчёт количества

#### **II. ДВОИЧНЫЙ ПОИСК (BINARY SEARCH)**

##### **A. КЛАССИЧЕСКИЙ БИНАРНЫЙ ПОИСК**
*   **Basic Binary Search:**
    *   Simple Binary Search
    *   Для отсортированных массивов
    *   O(log n) время
*   **Варианты реализации:**
    *   **Итеративная версия:**
        *   While loop с поддержанием границ
    *   **Рекурсивная версия:**
        *   Divide and conquer подход
*   **Точные варианты поиска:**
    *   **Lower bound:**
        *   Первый элемент ≥ x
        *   std::lower_bound в C++
    *   **Upper bound:**
        *   Первый элемент > x
        *   std::upper_bound в C++
    *   **Equal range:**
        *   Диапазон элементов равных x
        *   std::equal_range в C++

##### **B. БИНАРНЫЙ ПОИСК ПО ОТВЕТУ (BINARY SEARCH ON ANSWER)**
*   **Параметрический поиск:**
    *   Binary Search по ответу
    *   Когда ответ монотонен относительно параметра
*   **Применения:**
    *   Минимизация максимума
    *   Максимизация минимума
    *   Задачи с монотонными предикатами

##### **C. ВЕЩЕСТВЕННЫЙ БИНАРНЫЙ ПОИСК**
*   **Real-valued Binary Search:**
    *   Для функций с вещественным аргументом
    *   Поиск корня уравнения f(x) = 0
*   **Точность и критерии остановки:**
    *   Фиксированное число итераций (например, 100)
    *   По достижении заданной точности ε
    *   while (hi - lo > eps) { ... }
*   **Применения:**
    *   Нахождение корней уравнений
    *   Оптимизация вещественных функций
    *   Геометрические задачи

##### **D. БИНАРНЫЙ ПОИСК В ОСОБЫХ СТРУКТУРАХ**
*   **Binary Search в rotated/sorted array:**
    *   Поиск в циклически сдвинутом массиве
    *   Найти точку вращения (pivot)
*   **Binary Search в 2D/3D массивах:**
    *   Сначала по строкам, потом по столбцам
    *   Для row-wise/column-wise sorted матриц
*   **Binary Search в бесконечном массиве:**
    *   Exponential Search + Binary Search
    *   Поиск в потоке данных

#### **III. ПРОМЕЖУТОЧНЫЕ АЛГОРИТМЫ ПОИСКА**

##### **A. ПОИСК ПРОПУСКАНИЕМ (JUMP SEARCH)**
*   **Jump Search:**
    *   Прыжки фиксированного размера (√n)
    *   Затем линейный поиск в блоке
    *   O(√n) время, O(1) память
*   **Оптимальный размер прыжка:**
    *   √n минимизирует количество сравнений
    *   Для равномерного распределения
*   **Сравнение с Binary Search:**
    *   Лучше для sequential access (ленточные накопители)
    *   Хуже для random access (память)

##### **B. ИНТЕРПОЛЯЦИОННЫЙ ПОИСК (INTERPOLATION SEARCH)**
*   **Interpolation Search:**
    *   Для равномерно распределённых данных
    *   Предсказывает позицию элемента
    *   O(log log n) в среднем, O(n) в худшем
*   **Формула интерполяции**
*   **Применения:**
    *   Телефонные справочники
    *   Словари
    *   Любые равномерно распределённые данные

##### **C. ПОИСК ФИБОНАЧЧИ (FIBONACCI SEARCH)**
*   **Fibonacci Search:**
    *   Использует числа Фибоначчи для деления
    *   Только операции сложения/вычитания
    *   Полезно когда деление дорого
*   **Алгоритм:**
    *   Найти наименьшее F(k) ≥ n
    *   Сравнить с элементом arr[F(k-2)]
    *   Рекурсивно сужать диапазон
*   **Сравнение с Binary Search:**
    *   Меньше сравнений в среднем
    *   Сложнее реализация

##### **D. ЭКСПОНЕНЦИАЛЬНЫЙ ПОИСК (EXPONENTIAL SEARCH)**
*   **Exponential Search:**
    *   Для бесконечных/неизвестного размера массивов
    *   Сначала exponential range finding
    *   Затем binary search в найденном диапазоне
*   **Алгоритм:**
    1. i = 1
    2. Пока arr[i] < x: i *= 2
    3. Binary Search в [i/2, min(i, n-1)]
*   **Применения:**
    *   Поиск в неограниченных массивах
    *   Поиск в потоковых данных
    *   Когда размер массива неизвестен

#### **IV. ТРОИЧНЫЙ ПОИСК (TERNARY SEARCH)**

##### **A. КЛАССИЧЕСКИЙ ТРОИЧНЫЙ ПОИСК**
*   **Ternary Search:**
    *   Для унимодальных функций (имеющих один экстремум)
    *   Делит диапазон на три части
    *   O(log₃ n) итераций
*   **Типы унимодальных функций:**
    *   Strictly increasing then decreasing
    *   Strictly decreasing then increasing

##### **B. ВАРИАНТЫ ТРОИЧНОГО ПОИСКА**
*   **Целочисленный Ternary Search:**
    *   Для дискретных функций
    *   while (hi - lo >= 3) { ... }
*   **Вещественный Ternary Search:**
    *   Для непрерывных функций
    *   Критерий остановки по ε
*   **Golden Section Search:**
    *   Оптимальное деление интервала
    *   Использует золотое сечение φ ≈ 1.618
    *   Меньше вычислений функции

##### **C. ПРИМЕНЕНИЯ ТРОИЧНОГО ПОИСКА**
*   Нахождение максимума/минимума унимодальной функции
*   Задачи на параболы и квадратичные функции
*   Геометрические задачи (расстояния, площади)
*   Оптимизация в machine learning (линия поиска)

#### **V. ПОИСК ВЫБОРОК И МЕДИАНЫ (SELECTION ALGORITHMS)**

##### **A. БЫСТРЫЙ ВЫБОР (QUICKSELECT)**
*   **Quick Select:**
    *   O(n) в среднем, O(n²) в худшем
    *   На основе QuickSort partition
*   **Алгоритм:**
    1. Выбрать pivot
    2. Разделить массив вокруг pivot
    3. Рекурсивно искать в нужной части
*   **Randomized QuickSelect:**
    *   Случайный выбор pivot
    *   O(n) ожидаемое время

##### **B. МЕДИАНА МЕДИАН (MEDIAN OF MEDIANS)**
*   **Median of Medians (BFPRT):**
    *   Детерминированный O(n) алгоритм
    *   Blum, Floyd, Pratt, Rivest, Tarjan
*   **Алгоритм:**
    1. Разбить массив на группы по 5
    2. Найти медиану каждой группы
    3. Рекурсивно найти медиану медиан
    4. Использовать как pivot
*   **Сложность:**
    *   Гарантированно O(n)
    *   Константа ~3n сравнений

##### **C. ДРУГИЕ АЛГОРИТМЫ ВЫБОРА**
*   **IntroSelect:**
    *   Комбинация QuickSelect и Median of Medians
    *   Начинает с QuickSelect, переключается при плохом pivot
*   **HeapSelect:**
    *   С помощью min-heap или max-heap
    *   O(n log k) для k-го элемента
*   **Counting Select:**
    *   Для ограниченного диапазона значений
    *   O(n + range)

##### **D. НАХОЖДЕНИЕ МЕДИАНЫ**
*   **Медиана одного массива:**
    *   QuickSelect или Median of Medians
*   **Медиана двух отсортированных массивов:**
    *   Бинарный поиск за O(log min(m,n))
    *   Алгоритм за O(log(m+n))
*   **Медиана в потоке данных:**
    *   Two heaps approach (min-heap + max-heap)
    *   O(log n) на добавление

#### **VI. МЕТАЭВРИСТИКИ И ЛОКАЛЬНЫЙ ПОИСК**

##### **A. ПОИСК С ВОЗВРАТАМИ (BACKTRACKING)**
*   **Backtracking search:**
    *   Систематический перебор с отсечениями
    *   Для комбинаторных задач
*   **Применения:**
    *   N-Queens
    *   Sudoku Solver
    *   Graph coloring
*   **Оптимизации:**
    *   Forward checking
    *   Constraint propagation

##### **B. ПОИСК ПОДЪЁМОМ НА ХОЛМ (HILL CLIMBING)**
*   **Hill Climbing:**
    *   Локальный поиск в окрестности
    *   Всегда движется в направлении улучшения
*   **Варианты:**
    *   **Simple Hill Climbing:**
        *   Первый улучшающий ход
    *   **Steepest Ascent Hill Climbing:**
        *   Наилучший улучшающий ход
    *   **Stochastic Hill Climbing:**
        *   Случайный выбор из улучшающих
*   **Проблемы:**
    *   Локальные максимумы
    *   Плато (plateaus)
    *   Риджи (ridges)

##### **C. ИМИТАЦИЯ ОТЖИГА (SIMULATED ANNEALING)**
*   **Simulated Annealing:**
    *   Метод Монте-Карло для глобальной оптимизации
    *   Позволяет "плохие" ходы с уменьшающейся вероятностью
*   **Параметры:**
    *   Начальная температура T
    *   Функция охлаждения cooling(T)
    *   Критерий остановки

##### **D. ПОИСК С ЗАПРЕТАМИ (TABU SEARCH)**
*   **Tabu Search:**
    *   Запоминает недавние ходы (tabu list)
    *   Избегает циклов и локальных оптимумов
*   **Компоненты:**
    *   **Tabu list:** краткосрочная память
    *   **Aspiration criteria:** когда игнорировать tabu
    *   **Intensification:** углубление в хороших областях
    *   **Diversification:** исследование новых областей

##### **E. ГЕНЕТИЧЕСКИЕ АЛГОРИТМЫ (GENETIC ALGORITHMS)**
*   **Evolutionary search:**
    *   Популяция решений
    *   Selection, crossover, mutation
*   **Операторы:**
    *   **Fitness function:** оценка решения
    *   **Selection:** roulette, tournament, rank-based
    *   **Crossover:** one-point, two-point, uniform
    *   **Mutation:** random perturbation
*   **Параметры:**
    *   Population size
    *   Crossover rate
    *   Mutation rate
    *   Number of generations

##### **C. ИНФОРМИРОВАННЫЙ ПОИСК (HEURISTIC SEARCH)**
*   **A* Search:**
    *   f(n) = g(n) + h(n)
    *   g(n) - стоимость от start до n
    *   h(n) - эвристика до goal
*   **IDA* (Iterative Deepening A*):**
    *   Комбинация IDDFS и A*
    *   Memory efficient
*   **Beam Search:**
    *   Ограниченная версия BFS
    *   Сохраняет только k лучших узлов на каждом уровне

#### **VIII. СТРИМИНГОВЫЙ И ОНЛАЙН ПОИСК**

##### **A. ПОИСК В ПОТОКАХ ДАННЫХ**
*   **Reservoir Sampling:**
    *   Выбор случайного элемента из потока
    *   Выбор k случайных элементов
*   **Heavy Hitters:**
    *   Элементы, встречающиеся часто
    *   Misra-Gries, Count-Min Sketch
*   **Quantiles в потоке:**
    *   Greenwald-Khanna algorithm
    *   t-Digest algorithm

##### **B. ПРИБЛИЖЁННЫЙ ПОИСК**
*   **Locality-Sensitive Hashing (LSH):**
    *   Для approximate nearest neighbor
    *   Схожие элементы попадают в один bucket
*   **Bloom Filter:**
    *   Вероятностная структура
    *   Проверка принадлежности с ложными срабатываниями

#### **IX. ПАРАМЕТРИЧЕСКИЙ И МНОГОКРИТЕРИАЛЬНЫЙ ПОИСК**

##### **A. ПАРАМЕТРИЧЕСКИЙ ПОИСК**
*   **Parametric Search:**
    *   Преобразование задачи оптимизации в задачу принятия решения
    *   Binary Search по ответу + проверка feasibility
*   **Применения:**
    *   Scheduling problems
    *   Resource allocation
    *   Minimax problems

##### **B. МНОГОКРИТЕРИАЛЬНЫЙ ПОИСК**
*   **Pareto optimal search:**
    *   Поиск недоминируемых решений
    *   Skyline queries
*   **Multi-objective optimization:**
    *   Weighted sum approach
    *   ε-constraint method
    *   Evolutionary multi-objective optimization

#### **XII. ПАРАЛЛЕЛЬНЫЙ И РАСПРЕДЕЛЁННЫЙ ПОИСК**

##### **A. ПАРАЛЛЕЛЬНЫЕ АЛГОРИТМЫ**
*   **Parallel Binary Search:**
    *   Для multiple queries
    *   Offline processing
*   **Parallel Search in arrays:**
    *   SIMD instructions (vectorized search)
    *   OpenMP, MPI implementations

##### **B. РАСПРЕДЕЛЁННЫЙ ПОИСК**
*   **Distributed Hash Tables (DHT):**
    *   Chord, Kademlia, Pastry
    *   Поиск в P2P сетях
*   **MapReduce для поиска:**
    *   Распределённая индексация
    *   Inverted index construction

#### **XIII. КВАНТОВЫЙ И ПРОБАБИЛИСТИЧЕСКИЙ ПОИСК**

##### **A. КВАНТОВЫЕ АЛГОРИТМЫ**
*   **Grover's Algorithm:**
    *   Квантовый поиск в неструктурированной БД
    *   O(√N) вместо O(N)
*   **Quantum Walk Search:**
    *   Для структурированных данных
    *   Экспоненциальное ускорение для некоторых задач

##### **B. ВЕРОЯТНОСТНЫЙ ПОИСК**
*   **Randomized Search:**
    *   Monte Carlo methods
    *   Las Vegas algorithms
*   **Probabilistic Data Structures:**
    *   Bloom filter
    *   Count-Min Sketch
    *   HyperLogLog

#### **XIV. СПЕЦИАЛИЗИРОВАННЫЕ АЛГОРИТМЫ ПОИСКА**

##### **A. ПОИСК В СЖАТЫХ ДАННЫХ**
*   **Search in compressed arrays:**
    *   Elias-Fano encoding
    *   Search in succinct data structures
*   **Search in encrypted data:**
    *   Searchable symmetric encryption
    *   Homomorphic encryption for search

##### **B. ПОИСК С УЧЁТОМ КОНТЕКСТА**
*   **Context-aware search:**
    *   Semantic search
    *   Personalized search
*   **Federated Search:**
    *   Поиск по multiple sources
    *   Result aggregation

### **III. ЛИНЕЙНЫЕ АЛГОРИТМЫ И МЕТОДЫ СКАНА**

#### **A. МЕТОДЫ ДВУХ УКАЗАТЕЛЕЙ**
*   **Базовые техники двух указателей**
    *   **Встречные указатели** - сходятся к центру
    *   **Параллельные указатели** - движутся в одном направлении
    *   **Разделяющиеся указатели** - для разделения массива на части
    *   **Быстрый и медленный указатель** - для обнаружения циклов
*   **Применения двух указателей**
    *   **Поиск подмассивов** с заданными свойствами
    *   **Удаление дубликатов** в отсортированном массиве
    *   **Объединение интервалов**
    *   **Палиндромы** - проверка и поиск
*   **Оптимизированные алгоритмы**
    *   **Поиск медианы двух отсортированных массивов** за O(log(min(m,n)))
    *   **Трапециевидный обход** в матрицах
    *   **Z-сканирование** для кэш-оптимизации
*   **Сложные паттерны указателей**
    *   **Три указателя** - для задач 3Sum, сортировки 3 цветов
    *   **K указателей** - для слияния K отсортированных массивов
    *   **Вложенные указатели** - с разными шагами сканирования
    *   Указатели для слияния K отсортированных массивов

#### **B. АЛГОРИТМЫ СКОЛЬЗЯЩЕГО ОКНА**
*   **Техники скользящего окна**
    *   **Фиксированное окно** - постоянный размер окна
    *   **Динамическое окно** - переменный размер, удовлетворяющий условиям
    *   **Монотонное окно** - с поддержанием монотонной очереди
    *   **Многооконные методы** - несколько окон одновременно
    *   **Наложенные окна** - с перекрытием
    *   **Адаптивные окна**
        *   **С условиями на сумму/произведение**
        *   **С ограничениями на различные элементы**
        *   **Для строк с ограничениями на символы**
*   **Оптимизации скользящего окна**
    *   **Deque для максимумов/минимумов** в окне
    *   **Prefix sums** для быстрого пересчета сумм
    *   **Frequency maps** для задач с подстроками
*   **Специализированные оконные алгоритмы**
    *   **Алгоритм Липтона-Тарьяна** для скользящего медианного фильтра
    *   **Reservoir sampling** для случайной выборки из потока
    *   **Exponential histograms** для подсчета скользящих квантилей

#### **C. МЕТОД СКАНИРУЮЩЕЙ ПРЯМОЙ (SWEEP LINE)**
*   **Основные принципы**
    *   **Сортировка событий** по координате
    *   **Обработка событий** в порядке сканирования
    *   **Поддержание активных множеств**

#### **D. АЛГОРИТМЫ МАКСИМАЛЬНЫХ СУММ И ПОТОКОВ**
*   **Алгоритм Кадане (Kadane's Algorithm)**
    *   **Классический вариант** - максимальная сумма подмассива
    *   **2D вариант** - максимальная сумма подматрицы за O(n³)
    *   **Циркулярный вариант** - в циклическом массиве
    *   **K-ичный алгоритм Кадане** - для K максимальных сумм
*   **Расширенные версии**
    *   **С индексами** - возврат границ подмассива
    *   **С ограничениями** - минимальная/максимальная длина
    *   **Для матриц** - через сведение к 1D

#### **E. СИМПЛЕКС-МЕТОД И ЛИНЕЙНОЕ ПРОГРАММИРОВАНИЕ**
*   **Основы линейного программирования**
    *   **Теоретические основы**
        *   **Теорема двойственности** - primal-dual relationships
        *   **Теория двойственности** - двойственные задачи ЛП
    *   **Целочисленное линейное программирование** - методы отсечений
    *   **Целевая функция** - линейная функция для оптимизации
    *   **Ограничения** - линейные неравенства/равенства
    *   **Допустимая область** - выпуклый многогранник
*   **Симплекс-метод**
    *   **Каноническая форма** - приведение к стандартному виду
    *   **Симплекс-таблица** - матричное представление
    *   **Базисные переменные** и pivot операции
*   **Продвинутые варианты симплекс-метода**
    *   **Revised simplex method** - для больших разреженных задач
    *   **Dual simplex method** - для задач с изменяющимися ограничениями
    *   **Network simplex** - для сетевых задач потока
*   **Специальные случаи**
    *   **Вырожденность** и циклы
    *   **Неограниченные задачи**
    *   **Несовместные ограничения**
*   **Алгоритмы внутренней точки**
    *   **Karmarkar's algorithm** - первый полиномиальный алгоритм
    *   **Path-following methods** - следование центральному пути
    *   **Primal-dual methods** - одновременное решение primal и dual

#### **F. ВЕНГЕРСКИЙ АЛГОРИТМ**
*   **Задача о назначениях**
    *   **Постановка**: назначение n работников на n работ с минимальной стоимостью
    *   **Матрица стоимостей** C[i][j]
    *   **Перфектное паросочетание** в двудольном графе
*   **Алгоритм Куна-Мункреса (Венгерский алгоритм)**
    *   **Подготовка**: приведение матрицы
    *   **Поиск увеличивающей цепи**
    *   **Коррекция потенциалов**
*   **Оптимизации и варианты**
    *   **Для разреженных матриц**
    *   **С различными размерами** n × m
    *   **Максимизация** вместо минимизации
    *   **Венгерский алгоритм для разреженных матриц** за O(n²m)
    *   **Алгоритм Джонкер-Волгенаанта** - ускоренная версия
    *   **Потоковые алгоритмы** - сведение к задаче о максимальном потоке

### **IV. СЖАТИЕ ДАННЫХ - ПОЛНАЯ КЛАССИФИКАЦИЯ И АЛГОРИТМЫ**

#### **A. ТЕОРЕТИЧЕСКИЕ ОСНОВЫ СЖАТИЯ**
*   **Теория информации Шеннона**
    *   **Энтропия**: H(X) = -Σ p(x)log₂p(x) - мера информации
    *   **Сложность Колмогорова** - минимальный размер программы, воспроизводящей данные
    *   **Пределы сжатия** - теорема Шеннона о кодировании источников
*   **Метрики эффективности сжатия**
    *   **Степень сжатия**: (1 - сжатый_размер/оригинальный_размер) × 100%
    *   **Скорость сжатия/распаковки** - МБ/сек
    *   **Peak Signal to Noise Ratio (PSNR)** - для оценки качества сжатия с потерями
    *   **Bit per pixel (bpp)** - для изображений
*   **Классификация методов сжатия**
    *   **Без потерь (lossless)** - полное восстановление данных
    *   **С потерями (lossy)** - приемлемые потери качества
    *   **Адаптивные vs статические** методы
    *   **Симметричные vs асимметричные** по времени сжатия/распаковки

#### **B. СЖАТИЕ БЕЗ ПОТЕРЬ**
*   **Энтропийное кодирование**
    *   **Алгоритм Хаффмана** - префиксные коды с минимальной избыточностью
    *   **Арифметическое кодирование** - представление данных одним числом
    *   **Адаптивное кодирование Хаффмана** - без предварительного анализа частот
    *   **Коды Голомба и Райса** - для геометрических распределений
*   **Словарные методы**
    * Lempel Ziv - семейство алгоритмов Лемпеля-Зива
    * Lempel Ziv Decompress - алгоритмы распаковки для LZ-семейства
    *   **LZ77 (Лемпеля-Зива)** - скользящее окно и поиск совпадений
    *   **LZ78** - построение словаря фраз
    *   **LZW (Лемпеля-Зива-Велча)** - улучшенный LZ78 с фиксированной шириной кода
    *   **LZSS** - улучшенный LZ77 с битовыми флагами
*   **Преобразующие методы**
    *   **Run-Length Encoding (RLE)** - для данных с длинными сериями
    *   **Burrows-Wheeler Transform (BWT)** - перестановка для группировки символов
    *   **Move-to-Front (MTF)** - преобразование после BWT
    *   **Delta encoding** - кодирование разностей между последовательными значениями

#### **C. СЖАТИЕ С ПОТЕРЯМИ**
*   **Сжатие изображений**
    *   **JPEG** - дискретное косинусное преобразование (DCT)
    *   **JPEG 2000** - вейвлет-преобразование
    *   **WebP** - прогнозирующее кодирование
    *   **Quantization matrices** - таблицы квантования
*   **Сжатие аудио**
    *   **MP3** - психоакустическая модель и MDCT
    *   **AAC** - улучшенный MP3
    * **FLAC** - сжатие без потерь с прогнозированием
    * **Opus** - низкая задержка, высокое качество
*   **Сжатие видео**
    *   **H.264/AVC** - межкадровое и внутрикадровое предсказание
    *   **H.265/HEVC** - улучшенная эффективность сжатия
    *   **AV1** - открытый стандарт
    *   **Motion compensation** - компенсация движения

#### **D. СПЕЦИАЛИЗИРОВАННЫЕ МЕТОДЫ СЖАТИЯ**
*   **Сжатие координат (Coordinate Compression)**
*   **Дискретизация данных**
    *   **Равномерная дискретизация** - фиксированные интервалы
    *   **Квантование по значимости** - сохранение важных особенностей
    *   **Адаптивная дискретизация** - переменный шаг
*   **Сжатие графов**
    *   **WebGraph framework** - для веб-графов
    *   **K²-деревья** - для WebGraph
    *   **Сжатие матриц смежности**
*   **Сжатие баз данных**
    *   **Dictionary compression** - для строковых колонок
    *   **Bit-packing** - для целых чисел
    *   **Frame Of Reference (FOR)** - delta encoding для отсортированных данных

#### **E. ПРОДВИНУТЫЕ АЛГОРИТМЫ И ТЕХНИКИ**
*   **Адаптивные методы**
    *   **Context Modeling** - PPM (Prediction by Partial Matching)
    *   **PAQ** - нейросетевые предикторы контекста
    *   **Dynamic Markov Compression** - адаптивные марковские модели
*   **Преобразования и анализ**
    *   **Wavelet transforms** - вейвлет-анализ
    *   **Fourier transforms** - частотный анализ
    *   **Karhunen-Loève transform (KLT)** - оптимальное преобразование
    * Burrows Wheeler - полная реализация преобразования и обратного преобразования
*   **Гибридные методы**
    *   **BZip2** = BWT + MTF + RLE + Хаффман
    *   **DEFLATE** = LZ77 + Хаффман (используется в ZIP, gzip)
    *   **LZMA** = LZ77 + арифметическое кодирование

#### **F. ПРАКТИЧЕСКИЕ ПРИМЕНЕНИЯ И ФОРМАТЫ**
*   **Архиваторы**
    *   **ZIP** - DEFLATE алгоритм
    *   **7-Zip** - LZMA алгоритм
    *   **RAR** - проприетарный алгоритм
    *   **tar.gz** - комбинация tar и gzip
*   **Форматы файлов**
    *   **PNG** - сжатие без потерь с фильтрацией + DEFLATE
    *   **GIF** - LZW сжатие
    *   **PDF** - различные методы сжатия для разных типов контента
    *   **MP4** - контейнер для сжатого видео/аудио
*   **Системы хранения**
    *   **Deduplication** - устранение дубликатов данных
    *   **Compressed file systems** - прозрачное сжатие на уровне ФС
    *   **Database compression** - сжатие на уровне страниц

#### **G. АЛГОРИТМИЧЕСКИЕ ОПТИМИЗАЦИИ**
*   **Быстрые алгоритмы поиска совпадений**
    *   **Rolling hash** - для скользящего окна
    *   **Suffix arrays** - для поиска длинных совпадений
    *   **Hash chains** - в LZ77
*   **Эффективные структуры данных**
    *   **Circular buffers** - для скользящего окна
    *   **Priority queues** - для алгоритма Хаффмана
    *   **Tries** - для словарных методов
*   **Векторизация и параллелизм**
    *   **SIMD оптимизации** - для обработки нескольких символов одновременно
    *   **Многопоточное сжатие** - разделение данных на блоки
    *   **GPU ускорение** - для преобразований

#### **H. ТЕОРЕТИЧЕСКИЕ ГРАНИЦЫ И СЛОЖНОСТЬ**
*   **Теорема Шеннона** - предел сжатия без потерь
*   **Rate-distortion theory** - компромисс скорость-качество для сжатия с потерями
*   **Алгоритмическая сложность**
    *   Хаффман: O(n log n) время, O(n) память
    *   LZ77: O(n) время с хешированием, O(window_size) память
    *   BWT: O(n log n) время, O(n) память

#### **I. СОВРЕМЕННЫЕ ТЕНДЕНЦИИ**
*   **Нейросетевые методы сжатия**
    *   **Autoencoders** - для сжатия с потерями
    *   **Generative models** - для крайне агрессивного сжатия
    *   **Differentiable compression** - обучение end-to-end
*   **Сжатие для специальных применений**
    *   **Genomic data compression** - для ДНК последовательностей
    *   **Time series compression** - для сенсорных данных
    *   **3D model compression** - для компьютерной графики
*   **Аппаратное ускорение**
    *   **Dedicated compression chips**
    *   **FPGA implementations**
    *   **Hardware video encoders**

### **V. ЖАДНЫЕ АЛГОРИТМЫ**

#### ***A. ТЕОРЕТИЧЕСКИЕ ОСНОВЫ**
*   **Матроиды** (жадная оптимальность)

#### **B. ЗАДАЧИ ОПТИМИЗАЦИИ РАСПИСАНИЙ**
*   **Задача о расписании занятий**
*   **Задача о выборе заявок** (Activity Selection)
*   **Minimum Waiting Time** (минимизация времени ожидания)
*   **Optimal Merge Pattern** (оптимальное слияние - задача Хоффмана)
*   **Минимизация диапазона**
    Smallest Range
Задача Джонсона с одним станком ❌
Задача Джонсона с двумя станками ❌
Оптимальный выбор заданий при известных временах завершения и длительностях выполнения ❌

#### **C. ЗАДАЧИ РАЗМЕНА И ПОКУПОК**
*   **Задача о размене монет**
*   **Minimum Coin Change** (жадный вариант, когда возможен)
*   **Best Time To Buy And Sell Stock** (оптимальные моменты покупки/продажи)
*   **Gas Station** (задача о кругосветном путешествии с заправками)

#### **D. ЗАДАЧИ О РЮКЗАКЕ И ПОКРЫТИИ**
*   **Задача о рюкзаке (жадная)**
    *   Greedy Knapsack
    *   Knapsack (жадные варианты)
    *   Recursive Approach Knapsack (если жадный)
    *   Fractional Knapsack
    *   Fractional Knapsack 2
*   **Задача о минимальном покрытии**
*   **Fractional Cover Problem** (дробная задача покрытия)
Поиск подотрезка массива с максимальной/минимальной суммой за O(N) ❌

#### **H. ПЛАНИРОВАНИЕ**
First Come First Served, Highest Response Ratio Next, Job Sequence With Deadline, Job Sequencing With Deadline, Multi Level Feedback Queue, Non Preemptive Shortest Job First, Round Robin, Shortest Job First
*   **Задачи планирования работ**
    *   **Interval scheduling** - максимальное множество непересекающихся интервалов
    *   **Weighted interval scheduling** - с весами (решается ДП)
    *   **Job scheduling with deadlines** - минимизация штрафов
    *   **Task scheduling on multiple machines**
*   **Задачи распределения ресурсов**
    *   **Fractional knapsack** - рюкзак с дробными предметами
    *   **Resource allocation** - распределение ограниченных ресурсов
    *   **Bin packing** - упаковка в контейнеры (приближенные алгоритмы)

### **VI. ТЕОРИЯ ИГР - ПОЛНАЯ КЛАССИФИКАЦИЯ**

#### **A. ОСНОВНЫЕ ПОНЯТИЯ И КЛАССИФИКАЦИЯ ИГР**
*   **Формальное определение игры**
    *   Множество игроков
    *   Множество состояний и начальное состояние
    *   Множество действий и функция переходов
    * **Функция выигрыша/полезности**
    *   Терминальные состояния
*   **Классификация игр**
    *   **По количеству игроков**: антагонистические (2 игрока), кооперативные, n-игроков
    *   **По сумме выигрышей**: с нулевой суммой, с ненулевой суммой
    *   **По информации**: с полной информацией, с неполной информацией
    *   **По ходам**: последовательные, одновременные
    *   **По детерминированности**: детерминированные, стохастические

#### **B. ИГРЫ С ПОЛНОЙ ИНФОРМАЦИЕЙ**
*   **Дерево игры и его свойства**
    *   Построение полного дерева игры
    *   Оценка сложности (глубина, branching factor)
    *   Методы сокращения дерева
*   **Минимакс и альфа-бета отсечение**
    *   **Алгоритм минимакс** - рекурсивное вычисление оптимальной стратегии
    *   **Альфа-бета отсечение** - оптимизация минимакс
    *   **Killer heuristic** и **History heuristic** в альфа-бета
*   **Эвристики и оценочные функции**
    *   Построение оценочных функций для различных игр
    *   Методы обучения оценочных функций
    *   Quiescence search - поиск до "спокойной" позиции

#### **C. КОМБИНАТОРНАЯ ТЕОРИЯ ИГР**
*   **Выигрышные и проигрышные позиции**
    *   P-позиции (проигрышные) и N-позиции (выигрышные)
    *   Рекуррентное определение:
        - Терминальная позиция - P-позиция
        - Позиция, из которой есть ход в P-позицию - N-позиция
        - Позиция, из которой все ходы ведут в N-позиции - P-позиция
*   **Функция Гранди (Шпрага-Гранди)**
    *   **Определение**: G(position) = mex{G(positions reachable in one move)}
    *   **Теорема Шпрага-Гранди**: Позиция проигрышная тогда и только тогда, когда её число Гранди равно 0
    *   **Сумма игр**: G(game1 + game2) = G(game1) ⊕ G(game2)
    *   Применение к композитным играм
*   **Игра Ним и её варианты**
    *   **Классический ним**: G(x₁, x₂, ..., xₙ) = x₁ ⊕ x₂ ⊕ ... ⊕ xₙ
    *   **Ним в поддавки** (misère nim)
    *   **Варианты нима**: ним с ограничениями, ним с несколькими кучками

#### **D. ИГРЫ НА ГРАФАХ**
*   **Ациклические игровые графы**
    *   Метод ретроспективного анализа (обратный обход)
    *   Алгоритм за O(M) - обход в обратном топологическом порядке
*   **Циклические игровые графы**
    *   Проблема циклов и ничьих
    *   Алгоритмы для игр с циклами
    *   Стратегии для позиций с циклами

#### **H. СОВЕРШЕННАЯ ИГРА И РАВНОВЕСИЕ НЭША**
*   **Совершенная игра**
    *   Определение и свойства
    *   Существование оптимальных стратегий
    *   Цена игры
*   **Равновесие Нэша**
    *   Чистые и смешанные стратегии
    *   Существование в смешанных стратегиях
    *   Вычисление равновесий Нэша

#### **I. СТОХАСТИЧЕСКИЕ ИГРЫ**
*   **Игры со случайными ходами**
    *   Ожидаемый выигрыш
    *   Алгоритм Expectiminimax
*   **Марковские процессы принятия решений**
    *   Политики и функции ценности
    *   Алгоритм Value Iteration
    *   Алгоритм Policy Iteration

#### **J. ИГРЫ С НЕПОЛНОЙ ИНФОРМАЦИЕЙ**
*   **Байесовские игры**
    *   Типы игроков и априорные распределения
    *   Байесовское равновесие Нэша
*   **Игры с несовершенной информацией**
    *   Информационные множества
    *   Стратегии в играх с неполной информацией
    *   Проблема решения таких игр

#### **K. ПРАКТИЧЕСКИЕ ПРИМЕНЕНИЯ И АЛГОРИТМЫ**
*   **Монте-Карло методы**
    *   Monte Carlo Tree Search (MCTS)
    *   UCB1 formula для выбора ходов
    *   Применение в компьютерном Го
*   **Обучение с подкреплением в играх**
    *   Q-learning
    *   Deep Q-Networks (DQN)
    *   Policy Gradients
*   **Эвристические методы**
    *   Iterative Deepening
    *   Transposition Tables
    *   Opening Books и Endgame Tables

#### **L. КЛАССИЧЕСКИЕ ИГРЫ И ИХ АНАЛИЗ**
*   **Шахматы**
    *   Сложность: ~10¹²⁰ позиций
    *   Основные алгоритмы и эвристики
*   **Го**
    *   Сложность: ~10¹⁷⁰ позиций
    *   Подходы на основе MCTS и нейросетей
*   **Пятнашки (15-puzzle)**
    *   **Критерий разрешимости**: четность перестановки + позиция пустой клетки
    *   Алгоритмы поиска решения: A*, IDA*
    *   Эвристики: Манхэттенское расстояние, линейные конфликты
*   **Покер**
    *   Игра с неполной информацией
    *   Блеф и психологические аспекты
    *   Современные алгоритмы для покера

#### **M. ТЕОРЕТИЧЕСКИЕ ОСНОВЫ**
*   **Zermelo's theorem**: В любой конечной игре с полной информацией и нулевой суммой существует либо выигрышная стратегия для первого игрока, либо для второго, либо обе стороны могут форсировать ничью.
*   **Теорема Цермело-фон Неймана**: Любая конечная антагонистическая игра имеет значение и оптимальные стратегии.
*   **Сложность решения игр**:
    *   EXPTIME-complete: обобщенные шахматы, шашки
    *   PSPACE-complete: Го, Реверси
    *   NP-complete: многие головоломки

#### **N. АЛГОРИТМИЧЕСКИЕ ТЕХНИКИ**
*   **Bitboard представления** для эффективного хранения позиций
*   **Pattern databases** для эвристик
*   **Null-move pruning** и **Late Move Reductions**
